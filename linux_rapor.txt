

Arka mantÄ±ÄŸÄ± anlamadan diÄŸer tÃ¼m argÃ¼manlar benim iÃ§in â€œezberâ€ denilen kalÄ±p altÄ±nda toplanmÄ±ÅŸ, zaman kazandÄ±rmak dÄ±ÅŸÄ±nda pek iÅŸe yaramayan gereksiz argÃ¼manlardÄ±r. Bu yÃ¼zden Linuxâ€™ta Ã¶nce arka plan mantÄ±ÄŸÄ±nÄ± anlatmak isteyen birisiyimdir.

Linuxâ€™ta arka planÄ± anlatÄ±rken Ã§ok fazla â€œdosya, dosya, dosyaâ€ duyabiliriz. Bunun nedenini ileriki yazÄ±larda anlatacaÄŸÄ±m.
Burada anlatmak istediÄŸim ÅŸey; **shell mantÄ±ÄŸÄ±nÄ±n kernel Ã¼zerinde nasÄ±l iÅŸlediÄŸi, PATH vb.** olacak. Temelden nereden baÅŸlayacaÄŸÄ±mÄ± bilmiyorum Ã§Ã¼nkÃ¼ Linux zafif deÄŸil, derindir; temelden baÅŸlarsak karÄ±ÅŸabilir. Bu yÃ¼zden **en temelden baÅŸlayacaÄŸÄ±m ama en temel haliyle, Ã¶zet bir anlatÄ±m olacak.**

---

AslÄ±nda her ÅŸey UNIXâ€™in geliÅŸmesiyle baÅŸlamÄ±ÅŸtÄ±r.

UNIX, 1970â€™lerde geliÅŸtirilmiÅŸ bir sistem ailesidir.

* Ã‡ok kullanÄ±ÅŸlÄ±dÄ±r
* Ã‡ok gÃ¶revlidir
* Metin tabanlÄ± bir felsefeye sahiptir
* â€œHer ÅŸey bir dosyadÄ±râ€ mantÄ±ÄŸÄ±nÄ± ilk kuran sistemdir

GÃ¼nÃ¼mÃ¼ze geldiÄŸimizde lisanslÄ± ve Ã¼cretlidir. Tabii bir yerde bu durum deÄŸiÅŸecekti.

---

Bundan sonra Linux gelir.

Linux, 1991â€™de Linus Torvalds tarafÄ±ndan yazÄ±lan bir **Ã§ekirdektir (kernel)**.
DonanÄ±m ile programlar arasÄ±ndaki katmandÄ±r.
AslÄ±nda Linux tek baÅŸÄ±na bir iÅŸletim sistemi deÄŸildir; iÅŸletim sistemi Ã¶zelliklerini **tek baÅŸÄ±na gÃ¶stermez**.

---

Bundan sonra asÄ±l Ã¼Ã§lÃ¼den ortaya baÅŸka bir ÅŸey Ã§Ä±kar: **GNU**

GNU, Richard Stallmanâ€™Ä±n baÅŸlattÄ±ÄŸÄ± Ã¶zgÃ¼r yazÄ±lÄ±m projesidir. O zamanlar her ÅŸey kÄ±sÄ±tlÄ±, her ÅŸey kapalÄ± kaynak bir dÃ¶nemdir.
Richard Stallman Ã¶zgÃ¼r yazÄ±lÄ±m (free software) felsefesini bu dÃ¶nemde ortaya koymuÅŸtur.

Hatta olay ÅŸÃ¶yle yaÅŸanmÄ±ÅŸtÄ±r (renklendirilmiÅŸ haliyle):

> â€œYoldaÅŸlar! YazÄ±lÄ±mlarÄ±mÄ±n aÄŸzÄ±na sÄ±Ã§Ä±yorlar! BugÃ¼n saat 20:00â€™da parlamento binasÄ±nÄ±â€”â€

Tamam, bu biraz abartÄ± ama ruhu buydu. Elinde bÃ¶yle bir gÃ¼Ã§ yoktu tabii. Derken ikinci bir yoldaÅŸ gelir:

> â€œAl kernel yoldaÅŸÄ±m!â€

Ama GNUâ€™nun normalde bir kernelâ€™i yoktu. AraÃ§ seti gibi dÃ¼ÅŸÃ¼nÃ¼n.

GNU ÅŸunlarÄ± yaptÄ±:

* gcc
* bash
* coreutils (ls, cp, cat)
* glibc

Ama:

* âŒ Ã‡ekirdeÄŸi (kernel) eksikti

Sonra **Linux + GNU** birleÅŸti ve tam bir ÅŸey elde edildi (Selena mantÄ±ÄŸÄ±).
Bu yÃ¼zden bugÃ¼n kullandÄ±klarÄ±mÄ±za doÄŸrudan â€œLinuxâ€ demek teknik olarak doÄŸru deÄŸildir; doÄŸrusu **GNU/Linux**â€™tur.
Ama herkes Linux der. Neden?
ğŸ‘‰ ÃœÅŸengeÃ§lik.

Ã–zet tablo:

* UNIX â†’ Orijinal sistem ailesi
* Linux â†’ Ã‡ekirdek
* GNU â†’ KullanÄ±cÄ± alanÄ± araÃ§larÄ±
* Ubuntu / Fedora â†’ DaÄŸÄ±tÄ±m

Bunu kafanÄ±za yeterince oturttuÄŸunuzu varsayÄ±yorum.

---

Åimdi benim gelmek istediÄŸim nokta: **Terminal**

### TERMINAL

Terminal; komutlarÄ± yazdÄ±ÄŸÄ±mÄ±z ve bunlarÄ±n shell aracÄ±lÄ±ÄŸÄ±yla Ã§alÄ±ÅŸtÄ±rÄ±lÄ±p Ã§Ä±ktÄ±sÄ±nÄ±n bize gÃ¶sterildiÄŸi bir **komut arayÃ¼zÃ¼dÃ¼r**.
Herkesin terminali neredeyse aynÄ±dÄ±r (konfigÃ¼re edip kaplan falan ekleyip ÅŸekil ÅŸukul yapmadÄ±ysanÄ±z).

Yani terminali;
**komutlarÄ± yazÄ±p Ã§Ä±ktÄ±yÄ± okuyabildiÄŸimiz bir arayÃ¼z** gibi dÃ¼ÅŸÃ¼nebilirsiniz.

---

### SHELL

Shellâ€™in gÃ¶revi, komut arayÃ¼zÃ¼nden gelen argÃ¼manlarÄ± almaktÄ±r.
AslÄ±nda **her ÅŸey bir argÃ¼mandÄ±r**.

Ã–rneÄŸin ÅŸu cÃ¼mleye bakalÄ±m:

> â€œher ÅŸey bir argÃ¼mandÄ±râ€

Bunu parÃ§alara ayÄ±ralÄ±m:

* her ÅŸey â†’ argv[0]
* bir â†’ argv[1]
* argÃ¼mandÄ±r â†’ argv[2]

Shell bunlarÄ± ayÄ±rÄ±r.

Åimdi terminalinize ÅŸunu yazÄ±n:

```
ls -l /home
```

Shell ne yapar?

a) SatÄ±rÄ± parse eder
b) BoÅŸluklara gÃ¶re ayÄ±rÄ±r

* Komut: `ls`
* ArgÃ¼man 1: `-l`
* ArgÃ¼man 2: `/home`

Program tarafÄ±nda bu ÅŸÃ¶yle gÃ¶rÃ¼nÃ¼r:

* argv[0] = ls
* argv[1] = -l
* argv[2] = /home

`ls` programÄ±:

* ArgÃ¼manlarÄ± alÄ±r
* Ona gÃ¶re davranÄ±r
* Ã‡Ä±ktÄ±yÄ± terminale gÃ¶nderir

---

Ama bazen bu iÅŸler bÃ¶yle olmaz.

Mesela:
ls zaten var ama Linuxâ€™ta **python otomatik var mÄ±?**

Sizce neden Debianâ€™da:

```
sudo apt install python
```

yapÄ±yoruz abicim?

Ã‡Ã¼nkÃ¼ yok. Ä°ndirdik.

Ama sonra terminale sadece `python` yazÄ±yoruz ve Ã§alÄ±ÅŸÄ±yor.
Veri tabanÄ±nda mÄ± var? HayÄ±r.

Linux burada ÅŸunu der:

> â€œYeni gelen araÃ§larÄ± PATH ile bulacaÄŸÄ±m.â€

---

### PATH

PATH bir **ortam deÄŸiÅŸkenidir**.
Shell bir komut aldÄ±ÄŸÄ±nda, Ã§alÄ±ÅŸtÄ±rÄ±labilir dosyanÄ±n **nerede olduÄŸunu bulmak iÃ§in** PATHâ€™e bakar.

GÃ¶rmek iÃ§in:

```
echo $PATH
```

Ã–rnek Ã§Ä±ktÄ±:

```
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```

Ä°ki nokta (`:`) ayÄ±rÄ±cÄ±dÄ±r.

Shell soldan saÄŸa gider:

* Ã–nce `/usr/local/bin`
* Bulamazsa `/usr/bin`
* Sonra `/bin`

Ä°lk bulduÄŸu Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r.

PATHâ€™e dizin eklenebilir. YazÄ±lÄ±m indirince terminalden Ã§aÄŸÄ±rabilmemizin nedeni budur.
Ama bu **tehlikelidir**.

Bir hacker PATH manipÃ¼lasyonu ile yetki yÃ¼kseltebilir.
Bir ay Ã¶nce yaptÄ±ÄŸÄ±m salaklÄ±ÄŸÄ± siz yapmayÄ±n.

---

### Betik (Script)

Betik, iÃ§inde kabuk komutlarÄ± bulunan metin dosyasÄ±dÄ±r.
Program gibi Ã§alÄ±ÅŸtÄ±rÄ±labilir.

Ã–rnek:

```
echo "Program Ã‡alÄ±ÅŸtÄ±!"
```

---

### cat > betik.sh

Bu komut:

* `cat` â†’ girdiyi alÄ±r
* `>` â†’ dosyaya yÃ¶nlendirir
* `betik.sh` â†’ hedef dosya

Ctrl+D ile biter.

---

### KonfigÃ¼rasyon DosyalarÄ±

Bash baÅŸlarken bazÄ± dosyalarÄ± otomatik okur.

AmaÃ§:

* Ortam deÄŸiÅŸkenleri (PATH)
* Aliasâ€™lar
* Kabuk ayarlarÄ±

#### Sistem Geneli

* /etc/profile
* /etc/bashrc
* /etc/bash.bashrc

Root gerekir.

#### KullanÄ±cÄ± BazlÄ±

* ~/.bashrc
* ~/.bash_profile
* ~/.profile

Sadece o kullanÄ±cÄ±yÄ± etkiler.

Ã‡ok dosya olmasÄ±nÄ±n nedeni:
Login shell / non-login shell farklarÄ±.

EÄŸitim seviyesinde bilmek yeterli:
Hangisi varsa onu kullan.

---



### USER MODE â€“ KERNEL MODE

Linuxâ€™ta gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z komut arayÃ¼zÃ¼, Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±z programlar, shell, coreutils vb. **tamamÄ± user modeâ€™da Ã§alÄ±ÅŸÄ±r**.
Yani aslÄ±nda `ls`, `cat`, `bash`, `python` dediÄŸimiz her ÅŸey **user space** iÃ§indedir.

Ama bu programlarÄ±n **iÅŸlev kazanmasÄ±nÄ± saÄŸlayan**, onlarÄ± anlamlÄ± kÄ±lan ÅŸey **kernel**â€™dir.

Kernel;

* Dosya aÃ§ma
* Bellek yÃ¶netimi
* SÃ¼reÃ§ (process) yÃ¶netimi
* DonanÄ±m ile iletiÅŸim
* Klavye, disk, ekran gibi I/O iÅŸlemleri

gibi her ÅŸeyi kontrol eder.

Yani user modeâ€™daki bir program **tek baÅŸÄ±na hiÃ§bir ÅŸey yapamaz**.
Her ciddi iÅŸ iÃ§in kernelâ€™e gitmek zorundadÄ±r.

---

Åimdi iliÅŸkiyi net kuralÄ±m:

```
USER MODE  <---->  KERNEL MODE
```

User mode:

* KÄ±sÄ±tlÄ±dÄ±r
* DonanÄ±ma doÄŸrudan eriÅŸemez
* GÃ¼venlidir

Kernel mode (Ring 0):

* Tam yetkilidir
* DonanÄ±ma direkt eriÅŸir
* Sistemin kalbidir

---

Åimdi somut Ã¶rnekle gidelim.

Terminale ÅŸunu yazdÄ±n:

```
ls -l /home
```

Bu ne oldu?

1ï¸âƒ£ Komut terminalden shellâ€™e gider
Shell bunu alÄ±r, **argÃ¼man argÃ¼man ayÄ±rÄ±r**

2ï¸âƒ£ `ls` builtin mÄ± diye bakar â†’ âŒ
3ï¸âƒ£ PATHâ€™te Ã§alÄ±ÅŸtÄ±rÄ±labilir dosyayÄ± bulur â†’ `/bin/ls`

Bu aÅŸamaya kadar **her ÅŸey user modeâ€™da**.
HenÃ¼z kernelâ€™e gidilmedi.

---

4ï¸âƒ£ Bundan sonra shell ÅŸunu yapmak zorundadÄ±r:

> â€œBu programÄ± Ã§alÄ±ÅŸtÄ±râ€

Bunu kendi baÅŸÄ±na yapamaz.
Kernelâ€™e **bir sistem Ã§aÄŸrÄ±sÄ± (syscall)** gÃ¶nderir.

Burada kritik nokta ÅŸudur:

ğŸ”¥ `execve()` Ã§aÄŸrÄ±lÄ±r

Bu aslÄ±nda ÅŸunu demektir:

> â€œMevcut processâ€™i bu programla deÄŸiÅŸtirâ€

Yani:

* Yeni process yaratÄ±lmaz
* Bash processâ€™i **ls ile deÄŸiÅŸtirilir**
* Bellek temizlenir
* `/bin/ls` yÃ¼klenir

Bu tamamen **kernel mode** iÅŸidir.

---

5ï¸âƒ£ Kernel bu Ã§aÄŸrÄ±yÄ± alÄ±r

Kernel tarafÄ±nda:

* Syscall tablosuna bakÄ±lÄ±r
* `execve` â†’ ilgili kernel fonksiyonuna eÅŸlenir
* Gerekli `struct` yapÄ±larÄ± kullanÄ±lÄ±r
* Dosya sistemi Ã¼zerinden binary okunur
* BelleÄŸe map edilir

---

6ï¸âƒ£ ls Ã§alÄ±ÅŸÄ±rken:

* `/home` dizinini okumak ister
* Dosya bilgilerini almak ister

BunlarÄ±n hepsi tekrar tekrar **syscall** demektir:

* `open()`
* `getdents()`
* `stat()`
* `write()`

Ama ls bu Ã§aÄŸrÄ±larÄ± **doÄŸrudan donanÄ±ma yapmaz**.
Her seferinde kernelâ€™e gider.

---

7ï¸âƒ£ Kernel Ã§Ä±ktÄ±yÄ± Ã¼retir ama ÅŸuna dikkat eder:

> User mode belleÄŸine **gÃ¼venli** ÅŸekilde yazmak zorundadÄ±r

Bunun iÃ§in:

* `copy_to_user()`
  kullanÄ±lÄ±r.

Yani kernel, user mode belleÄŸine kafasÄ±na gÃ¶re dokunmaz.

---

SonuÃ§ta akÄ±ÅŸ ÅŸudur:

```
Komut ArayÃ¼zÃ¼
   â†“
Shell
   â†“
PATH kontrolÃ¼
   â†“
execve()  â† syscall
   â†“
Kernel (Ring 0)
   â†“
DonanÄ±m / FS / Bellek
   â†“
copy_to_user()
   â†“
Shell
   â†“
Terminal (Ã§Ä±ktÄ±)
```

---

Ã–zetle:

* **User mode**: programlarÄ±n yaÅŸadÄ±ÄŸÄ± gÃ¼venli alan
* **Kernel mode**: her ÅŸeyin gerÃ§ekten yapÄ±ldÄ±ÄŸÄ± yer
* AralarÄ±ndaki tek kÃ¶prÃ¼: **syscall**â€™lar

Bu yÃ¼zden Linuxâ€™ta â€œher ÅŸey dosyadÄ±râ€ lafÄ± kadar,
**â€œher ÅŸey kernelâ€™den geÃ§erâ€** lafÄ± da doÄŸrudur.


